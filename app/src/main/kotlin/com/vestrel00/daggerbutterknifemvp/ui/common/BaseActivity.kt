/*
 * Copyright 2018 Vandolf Estrellado
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.vestrel00.daggerbutterknifemvp.ui.common

import android.os.Bundle
import android.support.annotation.IdRes
import android.support.v4.app.DialogFragment
import android.support.v4.app.Fragment
import android.support.v7.app.AppCompatActivity
import com.vestrel00.daggerbutterknifemvp.navigation.Navigator
import dagger.android.AndroidInjection
import dagger.android.DispatchingAndroidInjector
import dagger.android.support.HasSupportFragmentInjector
import javax.inject.Inject

/**
 * Abstract Activity for all Activities to extend.
 *
 * **DEPENDENCY INJECTION**
 *
 * We could extend [dagger.android.support.DaggerAppCompatActivity] so we can get the boilerplate
 * dagger code for free. However, we want to avoid inheritance (if possible and it is in this case)
 * so that we have to option to inherit from something else later on if needed.
 */
abstract class BaseActivity : AppCompatActivity(), HasSupportFragmentInjector {

    @Inject
    lateinit var fragmentInjector: DispatchingAndroidInjector<Fragment>

    @Inject
    protected lateinit var navigator: Navigator

    /*
     * The property `fragmentManager` cannot be declared here with that name as it results in an
     * 'accidental override' compile-time error. Kotlin automatically generates getters for
     * properties. In this case, Kotlin generates a method called `getFragmentManager()` for the
     * property `fragmentManager`, which then conflicts with the Activity's `getFragmentManager()`
     * method.
     *
     * There are workarounds to this;
     *
     * 1. Change the property name to something else such as `activityFragmentManager`.
     * 2. Rename the getter generated by Kotlin using @get:JvmName("activityFragmentManager")
     *
     * However, we will not be doing any of the above because subclasses would have to use our
     * custom getter/property instead of the builtin `fragmentManager`, which may cause confusion.
     * Furthermore, Kotlin exposes the property `supportFragmentManager` from the getter
     * `getSupportFragmentManager()`, which will cause even greater confusion.
     *
     * The caveat to this is that we would need to use Robolectric in our tests in order to mock and
     * verify `FragmentManager` usages. For more details around testing (support) `FragmentManager`
     * usages, see https://github.com/vestrel00/android-dagger-butterknife-mvp/pull/52.
     */
    // @Inject
    // @field:Named(BaseActivityModule.ACTIVITY_FRAGMENT_MANAGER)
    // protected lateinit var fragmentManager: FragmentManager

    override fun onCreate(savedInstanceState: Bundle?) {
        AndroidInjection.inject(this)
        super.onCreate(savedInstanceState)
    }

    override fun supportFragmentInjector() = fragmentInjector

    protected fun addFragment(@IdRes containerViewId: Int, fragment: Fragment) {
        supportFragmentManager.beginTransaction()
                .add(containerViewId, fragment)
                .commit()
    }

    protected fun showDialogFragment(dialogFragment: DialogFragment, tag: String) =
            dialogFragment.show(supportFragmentManager, tag)
}